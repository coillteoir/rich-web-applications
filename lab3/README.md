# Lab 3 - Exercises

1. Instead of a large chunk of data all at once, you can instead continuously feed data to clients instead of forcing them to wait for a full download to complete. In terms of web development, we can think of asynchronous events such as I/O and network operations as streams. The observer pattern allows us to subscribe to a stream and be notified of any changes in said stream, for example observing a button's click event stream will notify the observer whenever the button is clicked and allow it to act on said event.
2. Using RxJS subscriptions instead of the Promise monad has a few benefits. Firstly, subscriptions are lazily executed rather than promises which are lazy. They are designed to handle multiple responses rather than having a promise assigned to each one. RxJS also provides constructs for observables since they can have a next, complete, and error function. Promises make more sense to use during single async tasks such as fetching data from the GitHub API. They require less setup and allow for elegant composition using the then functions. 
3. When sharing state between asynchronous tasks, you risk race conditions occurring since each task is producing it's own side effects on the state of the program. This could lead to data corruption. To alleviate this, we can write our asynchronous tasks as pure functions. By pure functions I mean functions which do not depend on, or manipulate external state. A function where it's output is only determined by it's inputs. By implementing asynchronous tasks as pure functions, you are mitigating any risk of race conditions or corruption.
